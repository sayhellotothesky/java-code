正则表达式概念

所谓正则表达式就是处理字符串的特殊字符串

用途

	字符串匹配(字符匹配)

	字符串查找(是建立在匹配之上的查找)

	字符串替换(是建立在查找的结果之后的替换)
  String类中的三个基本操作使用正则：
　　匹配：matches()
　　切割: split()
　　替换: replaceAll()

例如

	IP地址是否正确

	从网页中揪出Email地址

	从网页揪出链接

类

	java.lang.String

	java.util.regex.Pattern

	java.util.regex.Matcher

要点		

	//一个反斜线

	String str1 = "\\";

	//正则表达式的一个反斜线使用两个反斜线,在java中表示就再需要两个反斜线转义

	System.out.println(str1.matches("\\\\"));

	//POSIX Style,这种写法不建议使用,如果要使用查API

	System.out.println("a".matches("\\p{Lower}"));

	//空白行

	" \n".matches("^[\\s&&[^\n]]*\\n$");

	//邮箱

	String regex1 = "[\\w[.-]]+";

	String regex2 = "@";

	String regex3 = "[\\w[.-]]+";

	String regex4 = "\\.";

	String regex5 = "[\\w]+";

	String regex = regex1+regex2+regex3+regex4+regex5;

	System.out.println("156112846@qq.com".matches(regex));
正则表达式的基本语法

普通字符(字母,数字,汉字,下划线)		

	一个普通字符在表达式中只匹配与之相同的一个字符

	表达式k在字符串sky进行匹配时,将匹配成功

\r,\n,\t,\f

	表示回车符,换行符,制表符,换页符

.	

	任意一个字符

X?	

	表示X可以出现0次或者1次

X+	

	表示X可以出现1次或者多次

X*

	表示X可以出现任意次

X{n}

	表示X可以出现n次

X{m,n}

	表示X可以最少出现m次,最多出现n次

X{n,}

	表示X最少出现n次

[ ]

	匹配中括号中任意一个字符

[^ ]

	匹配中括号中字符之外的任意一个字符

\d

	表示0~9之间的任意一个数字字符,即[0-9]

\D

	表示0~9之外的任意数字字符,即[^0-9]

\r,\n,\t,\f

	表示回车符,换行符,制表符,换页符

\s

	表示空格,制表符,换页符等空白字符的任意一个

\S

	表示空白字符以外的任意一个字符,即[^\s]

\w

	表示字母,数字,下划线中的任意一个字符,即[a-zA-Z_0-9]

\W

	表示字母,数字,下划线以外的任意一个字符,即[^a-zA-Z_0-9]

^

	该符号不匹配任何字符,字符串开始的位置,即^h必须以h开头

$

	该符号不匹配任何字符,字符串结束的位置,即r$必须以r结尾

\b

	该符号不匹配任何字符,表示单词的边界

\B

	该符号不匹配任何字符,表示非单词的边界,即[^\b]

|

	用来连接两个表达式,表示或的关系

	X|Y 表示X或者Y中的任意字符

()

	作为一个单元,一个分组

\n(n表示一个数字)

	有分组的情况下,表示对分组的引用

	\1表示对分组1的引用

\

	转义字符,当一个符号自身有意义而又要表示这个字符的时候,就需要转义

	\^表示^,\$表示$

?

	如果在?,+,*,{n},{m,n},{n,}后面,表示次数按非贪婪模式进行匹配,

		即按照匹配模式进行最小限度的匹配
正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生，而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。

大家都知道，正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

  自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。

 因为正则表达式是一个很庞杂的体系，所以我仅例举些入门的概念，更多的请参阅相关书籍及自行摸索。

*下面是java中正则表达式常用的语法：

字符的取值范围
1.[abc] : 表示可能是a，可能是b，也可能是c。
2.[^abc]: 表示不是a,b,c中的任意一个
3.[a-zA-Z]: 表示是英文字母
4.[0-9]:表示是数字

简洁的字符表示
.：匹配任意的字符
\d：表示数字
\D：表示非数字
\s：表示由空字符组成，[ \t\n\r\x\f]
\S：表示由非空字符组成，[^\s]
\w：表示字母、数字、下划线，[a-zA-Z0-9_]
\W：表示不是由字母、数字、下划线组成

数量表达式
1.?: 表示出现0次或1次
2.+: 表示出现1次或多次
3.*: 表示出现0次、1次或多次
4.{n}：表示出现n次
5.{n,m}：表示出现n~m次
6.{n,}：表示出现n次或n次以上

逻辑表达式
1.XY: 表示X后面跟着Y，这里X和Y分别是正则表达式的一部分
2.X|Y：表示X或Y，比如"food|f"匹配的是foo（d或f），而"(food)|f"匹配的是food或f
3.(X):子表达式，将X看做是一个整体

java中提供了两个类来支持正则表达式的操作
分别是java.util.regex下的Pattern类和Matcher类
使用Pattern类进行字符串的拆分，使用的方法是String[] split(CharSequence input)
使用Matcher类进行字符串的验证和替换，
匹配使用的方法是boolean matches()
替换使用的方法是 String replaceAll(String replacement)

Pattern类的构造方法是私有的
所以我们使用Pattern p = Pattern.compile("a*b");进行实例化
Matcher类的实例化依赖Pattern类的对象Matcher m = p.matcher("aaaaab");

在实际的开发中，为了方便我们很少直接使用Pattern类或Matcher类，而是使用String类下的方法
验证：boolean matches(String regex)
拆分: String[] split(String regex)
替换： String replaceAll(String regex, String replacement)
